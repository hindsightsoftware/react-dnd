(function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if(typeof define === 'function' && define.amd)
        define(factory);
    else if(typeof exports === 'object')
        exports["ReactDND"] = factory();
    else
        root["ReactDND"] = factory();
})(this, function() {
    return /******/ (function(modules) { // webpackBootstrap
        /******/ 	// The module cache
        /******/ 	var installedModules = {};
        /******/
        /******/ 	// The require function
        /******/ 	function __webpack_require__(moduleId) {
            /******/
            /******/ 		// Check if module is in cache
            /******/ 		if(installedModules[moduleId])
            /******/ 			return installedModules[moduleId].exports;
            /******/
            /******/ 		// Create a new module (and put it into the cache)
            /******/ 		var module = installedModules[moduleId] = {
                /******/ 			exports: {},
                /******/ 			id: moduleId,
                /******/ 			loaded: false
                /******/ 		};
            /******/
            /******/ 		// Execute the module function
            /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ 		// Flag the module as loaded
            /******/ 		module.loaded = true;
            /******/
            /******/ 		// Return the exports of the module
            /******/ 		return module.exports;
            /******/ 	}
        /******/
        /******/
        /******/ 	// expose the modules object (__webpack_modules__)
        /******/ 	__webpack_require__.m = modules;
        /******/
        /******/ 	// expose the module cache
        /******/ 	__webpack_require__.c = installedModules;
        /******/
        /******/ 	// __webpack_public_path__
        /******/ 	__webpack_require__.p = "";
        /******/
        /******/ 	// Load entry module and return exports
        /******/ 	return __webpack_require__(0);
        /******/ })
    /************************************************************************/
    /******/ ([
        /* 0 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var _require = __webpack_require__(34);

            var HTML5 = _require.HTML5;
            var createDragDropMixin = __webpack_require__(41);

            module.exports = {
                DragDropMixin: createDragDropMixin(HTML5),
                ImagePreloaderMixin: __webpack_require__(36),
                DragLayerMixin: __webpack_require__(35),
                HorizontalDragAnchors: __webpack_require__(21),
                VerticalDragAnchors: __webpack_require__(22),
                NativeDragItemTypes: __webpack_require__(10),
                DropEffects: __webpack_require__(9)
            };

            /***/ },
        /* 1 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
             * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(1);
             * // => false
             */
            function isObject(value) {
                // Avoid a V8 JIT bug in Chrome 19-20.
                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
                var type = typeof value;
                return !!value && (type == 'object' || type == 'function');
            }

            module.exports = isObject;


            /***/ },
        /* 2 */
        /***/ function(module, exports, __webpack_require__) {

            var getLength = __webpack_require__(69),
                isLength = __webpack_require__(5);

            /**
             * Checks if `value` is array-like.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
             */
            function isArrayLike(value) {
                return value != null && isLength(getLength(value));
            }

            module.exports = isArrayLike;


            /***/ },
        /* 3 */
        /***/ function(module, exports, __webpack_require__) {

            /** Used as the `TypeError` message for "Functions" methods. */
            var FUNC_ERROR_TEXT = 'Expected a function';

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeMax = Math.max;

            /**
             * Creates a function that invokes `func` with the `this` binding of the
             * created function and arguments from `start` and beyond provided as an array.
             *
             * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
             *
             * @static
             * @memberOf _
             * @category Function
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @returns {Function} Returns the new function.
             * @example
             *
             * var say = _.restParam(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
             *
             * say('hello', 'fred', 'barney', 'pebbles');
             * // => 'hello fred, barney, & pebbles'
             */
            function restParam(func, start) {
                if (typeof func != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
                return function() {
                    var args = arguments,
                        index = -1,
                        length = nativeMax(args.length - start, 0),
                        rest = Array(length);

                    while (++index < length) {
                        rest[index] = args[start + index];
                    }
                    switch (start) {
                        case 0: return func.call(this, rest);
                        case 1: return func.call(this, args[0], rest);
                        case 2: return func.call(this, args[0], args[1], rest);
                    }
                    var otherArgs = Array(start + 1);
                    index = -1;
                    while (++index < start) {
                        otherArgs[index] = args[index];
                    }
                    otherArgs[start] = rest;
                    return func.apply(this, otherArgs);
                };
            }

            module.exports = restParam;


            /***/ },
        /* 4 */
        /***/ function(module, exports, __webpack_require__) {

            var isNative = __webpack_require__(74);

            /**
             * Gets the native function at `key` of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the method to get.
             * @returns {*} Returns the function if it's native, else `undefined`.
             */
            function getNative(object, key) {
                var value = object == null ? undefined : object[key];
                return isNative(value) ? value : undefined;
            }

            module.exports = getNative;


            /***/ },
        /* 5 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
             * of an array-like value.
             */
            var MAX_SAFE_INTEGER = 9007199254740991;

            /**
             * Checks if `value` is a valid array-like length.
             *
             * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
             */
            function isLength(value) {
                return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }

            module.exports = isLength;


            /***/ },
        /* 6 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Checks if `value` is object-like.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
             */
            function isObjectLike(value) {
                return !!value && typeof value == 'object';
            }

            module.exports = isObjectLike;


            /***/ },
        /* 7 */
        /***/ function(module, exports, __webpack_require__) {

            var getNative = __webpack_require__(4),
                isLength = __webpack_require__(5),
                isObjectLike = __webpack_require__(6);

            /** `Object#toString` result references. */
            var arrayTag = '[object Array]';

            /** Used for native method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objToString = objectProto.toString;

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeIsArray = getNative(Array, 'isArray');

            /**
             * Checks if `value` is classified as an `Array` object.
             *
             * @static
             * @memberOf _
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
             * @example
             *
             * _.isArray([1, 2, 3]);
             * // => true
             *
             * _.isArray(function() { return arguments; }());
             * // => false
             */
            var isArray = nativeIsArray || function(value) {
                    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                };

            module.exports = isArray;


            /***/ },
        /* 8 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var keyMirror = __webpack_require__(19);

            var DragDropActionTypes = keyMirror({
                DRAG_START: null,
                DRAG_END: null,
                DRAG: null,
                DROP: null
            });

            module.exports = DragDropActionTypes;

            /***/ },
        /* 9 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DropEffects = {
                COPY: "copy",
                MOVE: "move",
                LINK: "link"
            };

            module.exports = DropEffects;

            /***/ },
        /* 10 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var NativeDragItemTypes = {
                FILE: "__NATIVE_FILE__",
                URL: "__NATIVE_URL__"
            };

            module.exports = NativeDragItemTypes;

            /***/ },
        /* 11 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var Dispatcher = __webpack_require__(50).Dispatcher,
                assign = __webpack_require__(17);

            var DragDropDispatcher = assign(new Dispatcher(), {
                handleAction: function handleAction(action) {
                    this.dispatch({
                        action: action
                    });
                }
            });

            module.exports = DragDropDispatcher;

            /***/ },
        /* 12 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragDropDispatcher = __webpack_require__(11),
                DragDropActionTypes = __webpack_require__(8),
                createStore = __webpack_require__(24);

            var _initialOffsetFromContainer = null,
                _initialOffsetFromClient = null,
                _currentOffsetFromClient = null;

            var DragOffsetStore = createStore({
                getInitialOffsetFromContainer: function getInitialOffsetFromContainer() {
                    return _initialOffsetFromContainer;
                },

                getInitialOffsetFromClient: function getInitialOffsetFromClient() {
                    return _initialOffsetFromClient;
                },

                getCurrentOffsetFromClient: function getCurrentOffsetFromClient() {
                    return _currentOffsetFromClient;
                }
            });

            DragOffsetStore.dispatchToken = DragDropDispatcher.register(function (payload) {
                var action = payload.action;


                switch (action.type) {
                    case DragDropActionTypes.DRAG_START:
                        _initialOffsetFromContainer = action.offsetFromContainer;
                        _initialOffsetFromClient = action.offsetFromClient;
                        _currentOffsetFromClient = action.offsetFromClient;
                        DragOffsetStore.emitChange();
                        break;

                    case DragDropActionTypes.DRAG:
                        _currentOffsetFromClient = action.offsetFromClient;
                        DragOffsetStore.emitChange();
                        break;

                    case DragDropActionTypes.DRAG_END:
                        _initialOffsetFromContainer = null;
                        _initialOffsetFromClient = null;
                        _currentOffsetFromClient = null;
                        DragOffsetStore.emitChange();
                }
            });

            module.exports = DragOffsetStore;

            /***/ },
        /* 13 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragDropDispatcher = __webpack_require__(11),
                DragDropActionTypes = __webpack_require__(8),
                DragOffsetStore = __webpack_require__(12),
                createStore = __webpack_require__(24);

            var _draggedItem = null,
                _draggedItemType = null,
                _effectsAllowed = null,
                _dropEffect = null;

            var DragOperationStore = createStore({
                isDragging: function isDragging() {
                    return !!_draggedItem;
                },

                getEffectsAllowed: function getEffectsAllowed() {
                    return _effectsAllowed;
                },

                getDropEffect: function getDropEffect() {
                    return _dropEffect;
                },

                getDraggedItem: function getDraggedItem() {
                    return _draggedItem;
                },

                getDraggedItemType: function getDraggedItemType() {
                    return _draggedItemType;
                }
            });

            DragOperationStore.dispatchToken = DragDropDispatcher.register(function (payload) {
                DragDropDispatcher.waitFor([DragOffsetStore.dispatchToken]);

                var action = payload.action;


                switch (action.type) {
                    case DragDropActionTypes.DRAG_START:
                        _dropEffect = null;
                        _draggedItem = action.item;
                        _draggedItemType = action.itemType;
                        _effectsAllowed = action.effectsAllowed;
                        DragOperationStore.emitChange();
                        break;

                    case DragDropActionTypes.DROP:
                        _dropEffect = action.dropEffect;
                        DragOperationStore.emitChange();
                        break;

                    case DragDropActionTypes.DRAG_END:
                        _draggedItem = null;
                        _draggedItemType = null;
                        _effectsAllowed = null;
                        _dropEffect = null;
                        DragOperationStore.emitChange();
                        break;
                }
            });

            module.exports = DragOperationStore;

            /***/ },
        /* 14 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            function isSafari() {
                return !!window.safari;
            }

            module.exports = isSafari;

            /***/ },
        /* 15 */
        /***/ function(module, exports, __webpack_require__) {

            /** Used to detect unsigned integer values. */
            var reIsUint = /^\d+$/;

            /**
             * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
             * of an array-like value.
             */
            var MAX_SAFE_INTEGER = 9007199254740991;

            /**
             * Checks if `value` is a valid array-like index.
             *
             * @private
             * @param {*} value The value to check.
             * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
             * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
             */
            function isIndex(value, length) {
                value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return value > -1 && value % 1 == 0 && value < length;
            }

            module.exports = isIndex;


            /***/ },
        /* 16 */
        /***/ function(module, exports, __webpack_require__) {

            var isArrayLike = __webpack_require__(2),
                isObjectLike = __webpack_require__(6);

            /** Used for native method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /** Native method references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable;

            /**
             * Checks if `value` is classified as an `arguments` object.
             *
             * @static
             * @memberOf _
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
             * @example
             *
             * _.isArguments(function() { return arguments; }());
             * // => true
             *
             * _.isArguments([1, 2, 3]);
             * // => false
             */
            function isArguments(value) {
                return isObjectLike(value) && isArrayLike(value) &&
                    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
            }

            module.exports = isArguments;


            /***/ },
        /* 17 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright 2014, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             *
             * @providesModule Object.assign
             */

            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

            function assign(target, sources) {
                if (target == null) {
                    throw new TypeError('Object.assign target cannot be null or undefined');
                }

                var to = Object(target);
                var hasOwnProperty = Object.prototype.hasOwnProperty;

                for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
                    var nextSource = arguments[nextIndex];
                    if (nextSource == null) {
                        continue;
                    }

                    var from = Object(nextSource);

                    // We don't currently support accessors nor proxies. Therefore this
                    // copy cannot throw. If we ever supported this then we must handle
                    // exceptions and side-effects. We don't support symbols so they won't
                    // be transferred.

                    for (var key in from) {
                        if (hasOwnProperty.call(from, key)) {
                            to[key] = from[key];
                        }
                    }
                }

                return to;
            };

            module.exports = assign;


            /***/ },
        /* 18 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright 2013-2014, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             *
             * @providesModule invariant
             */

            "use strict";

            /**
             * Use invariant() to assert state which your program assumes to be true.
             *
             * Provide sprintf-style format (only %s is supported) and arguments
             * to provide information about what broke and what you were
             * expecting.
             *
             * The invariant message will be stripped in production, but the invariant
             * will remain to ensure logic does not differ in production.
             */

            var invariant = function(condition, format, a, b, c, d, e, f) {
                if (false) {
                    if (format === undefined) {
                        throw new Error('invariant requires an error message argument');
                    }
                }

                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error(
                            'Minified exception occurred; use the non-minified dev environment ' +
                            'for the full error message and additional helpful warnings.'
                        );
                    } else {
                        var args = [a, b, c, d, e, f];
                        var argIndex = 0;
                        error = new Error(
                            'Invariant Violation: ' +
                            format.replace(/%s/g, function() { return args[argIndex++]; })
                        );
                    }

                    error.framesToPop = 1; // we don't care about invariant's own frame
                    throw error;
                }
            };

            module.exports = invariant;


            /***/ },
        /* 19 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright 2013-2014, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             *
             * @providesModule keyMirror
             * @typechecks static-only
             */

            "use strict";

            var invariant = __webpack_require__(18);

            /**
             * Constructs an enumeration with keys equal to their value.
             *
             * For example:
             *
             *   var COLORS = keyMirror({blue: null, red: null});
             *   var myColor = COLORS.blue;
             *   var isColorValid = !!COLORS[myColor];
             *
             * The last line could not be performed if the values of the generated enum were
             * not equal to their keys.
             *
             *   Input:  {key1: val1, key2: val2}
             *   Output: {key1: key1, key2: key2}
             *
             * @param {object} obj
             * @return {object}
             */
            var keyMirror = function(obj) {
                var ret = {};
                var key;
                (false ? invariant(
                    obj instanceof Object && !Array.isArray(obj),
                    'keyMirror(...): Argument must be an object.'
                ) : invariant(obj instanceof Object && !Array.isArray(obj)));
                for (key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    ret[key] = key;
                }
                return ret;
            };

            module.exports = keyMirror;


            /***/ },
        /* 20 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragDropDispatcher = __webpack_require__(11),
                DragDropActionTypes = __webpack_require__(8);

            var DragDropActionCreators = {
                startDragging: function startDragging(itemType, item, effectsAllowed, offsetFromClient, offsetFromContainer) {
                    DragDropDispatcher.handleAction({
                        type: DragDropActionTypes.DRAG_START,
                        itemType: itemType,
                        item: item,
                        effectsAllowed: effectsAllowed,
                        offsetFromClient: offsetFromClient,
                        offsetFromContainer: offsetFromContainer
                    });
                },

                drag: function drag(offsetFromClient) {
                    DragDropDispatcher.handleAction({
                        type: DragDropActionTypes.DRAG,
                        offsetFromClient: offsetFromClient
                    });
                },

                recordDrop: function recordDrop(dropEffect) {
                    DragDropDispatcher.handleAction({
                        type: DragDropActionTypes.DROP,
                        dropEffect: dropEffect
                    });
                },

                endDragging: function endDragging() {
                    DragDropDispatcher.handleAction({
                        type: DragDropActionTypes.DRAG_END
                    });
                }
            };

            module.exports = DragDropActionCreators;

            /***/ },
        /* 21 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var keyMirror = __webpack_require__(19);

            var HorizontalDragAnchors = keyMirror({
                LEFT: null,
                CENTER: null,
                RIGHT: null
            });

            module.exports = HorizontalDragAnchors;

            /***/ },
        /* 22 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var keyMirror = __webpack_require__(19);

            var VerticalDragAnchors = keyMirror({
                TOP: null,
                CENTER: null,
                BOTTOM: null
            });

            module.exports = VerticalDragAnchors;

            /***/ },
        /* 23 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

            var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

            var union = __webpack_require__(53),
                without = __webpack_require__(54);

            var EnterLeaveMonitor = (function () {
                function EnterLeaveMonitor() {
                    _classCallCheck(this, EnterLeaveMonitor);

                    this._entered = [];
                }

                _prototypeProperties(EnterLeaveMonitor, null, {
                    enter: {
                        value: function enter(enteringNode) {
                            this._entered = union(this._entered.filter(function (node) {
                                return document.body.contains(node) && (!node.contains || node.contains(enteringNode));
                            }), [enteringNode]);

                            return this._entered.length === 1;
                        },
                        writable: true,
                        configurable: true
                    },
                    leave: {
                        value: function leave(leavingNode) {
                            this._entered = without(this._entered.filter(function (node) {
                                return document.body.contains(node);
                            }), leavingNode);

                            return this._entered.length === 0;
                        },
                        writable: true,
                        configurable: true
                    },
                    reset: {
                        value: function reset() {
                            this._entered = [];
                        },
                        writable: true,
                        configurable: true
                    }
                });

                return EnterLeaveMonitor;
            })();

            module.exports = EnterLeaveMonitor;

            /***/ },
        /* 24 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var EventEmitter = __webpack_require__(80).EventEmitter,
                assign = __webpack_require__(17),
                CHANGE_EVENT = "change";

            function createStore(spec) {
                var store = assign({
                    emitChange: function emitChange() {
                        this.emit(CHANGE_EVENT);
                    },

                    addChangeListener: function addChangeListener(callback) {
                        this.on(CHANGE_EVENT, callback);
                    },

                    removeChangeListener: function removeChangeListener(callback) {
                        this.removeListener(CHANGE_EVENT, callback);
                    }
                }, spec, EventEmitter.prototype);

                store.setMaxListeners(0);

                return store;
            }

            module.exports = createStore;

            /***/ },
        /* 25 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            function isFileDragDropEvent(e) {
                if (!e.dataTransfer) {
                    return false;
                }

                var types = Array.prototype.slice.call(e.dataTransfer.types);
                return types.indexOf("Files") !== -1;
            }

            module.exports = isFileDragDropEvent;

            /***/ },
        /* 26 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var NativeDragItemTypes = __webpack_require__(10);

            function isNativeDraggedItemType(itemType) {
                switch (itemType) {
                    case NativeDragItemTypes.FILE:
                    case NativeDragItemTypes.URL:
                        return true;
                    default:
                        return false;
                }
            }

            module.exports = isNativeDraggedItemType;

            /***/ },
        /* 27 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            function isUrlDragDropEvent(e) {
                var types = Array.prototype.slice.call(e.dataTransfer.types);
                return types.indexOf("Url") !== -1 || types.indexOf("text/uri-list") !== -1;
            }

            module.exports = isUrlDragDropEvent;

            /***/ },
        /* 28 */
        /***/ function(module, exports, __webpack_require__) {

            var indexOfNaN = __webpack_require__(70);

            /**
             * The base implementation of `_.indexOf` without support for binary searches.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseIndexOf(array, value, fromIndex) {
                if (value !== value) {
                    return indexOfNaN(array, fromIndex);
                }
                var index = fromIndex - 1,
                    length = array.length;

                while (++index < length) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return -1;
            }

            module.exports = baseIndexOf;


            /***/ },
        /* 29 */
        /***/ function(module, exports, __webpack_require__) {

            var isObject = __webpack_require__(1);

            /**
             * Checks if `value` is in `cache` mimicking the return signature of
             * `_.indexOf` by returning `0` if the value is found, else `-1`.
             *
             * @private
             * @param {Object} cache The cache to search.
             * @param {*} value The value to search for.
             * @returns {number} Returns `0` if `value` is found, else `-1`.
             */
            function cacheIndexOf(cache, value) {
                var data = cache.data,
                    result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

                return result ? 0 : -1;
            }

            module.exports = cacheIndexOf;


            /***/ },
        /* 30 */
        /***/ function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(global) {var SetCache = __webpack_require__(55),
                getNative = __webpack_require__(4);

                /** Native method references. */
                var Set = getNative(global, 'Set');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeCreate = getNative(Object, 'create');

                /**
                 * Creates a `Set` cache object to optimize linear searches of large arrays.
                 *
                 * @private
                 * @param {Array} [values] The values to cache.
                 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
                 */
                function createCache(values) {
                    return (nativeCreate && Set) ? new SetCache(values) : null;
                }

                module.exports = createCache;

                /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

            /***/ },
        /* 31 */
        /***/ function(module, exports, __webpack_require__) {

            var getNative = __webpack_require__(4),
                isArrayLike = __webpack_require__(2),
                isObject = __webpack_require__(1),
                shimKeys = __webpack_require__(72);

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeKeys = getNative(Object, 'keys');

            /**
             * Creates an array of the own enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects. See the
             * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
             * for more details.
             *
             * @static
             * @memberOf _
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keys(new Foo);
             * // => ['a', 'b'] (iteration order is not guaranteed)
             *
             * _.keys('hi');
             * // => ['0', '1']
             */
            var keys = !nativeKeys ? shimKeys : function(object) {
                var Ctor = object == null ? undefined : object.constructor;
                if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                    (typeof object != 'function' && isArrayLike(object))) {
                    return shimKeys(object);
                }
                return isObject(object) ? nativeKeys(object) : [];
            };

            module.exports = keys;


            /***/ },
        /* 32 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * A no-operation function that returns `undefined` regardless of the
             * arguments it receives.
             *
             * @static
             * @memberOf _
             * @category Utility
             * @example
             *
             * var object = { 'user': 'fred' };
             *
             * _.noop(object) === undefined;
             * // => true
             */
            function noop() {
                // No operation performed.
            }

            module.exports = noop;


            /***/ },
        /* 33 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragDropActionCreators = __webpack_require__(20),
                DragOperationStore = __webpack_require__(13),
                NativeDragItemTypes = __webpack_require__(10),
                EnterLeaveMonitor = __webpack_require__(23),
                isFileDragDropEvent = __webpack_require__(25),
                isUrlDragDropEvent = __webpack_require__(27),
                isNativeDraggedItemType = __webpack_require__(26),
                configureDataTransfer = __webpack_require__(40),
                shallowEqual = __webpack_require__(79),
                isWebkit = __webpack_require__(48);

            var ELEMENT_NODE = 1;

            // Store global state for browser-specific fixes and workarounds
            var _monitor = new EnterLeaveMonitor(),
                _currentDragTarget,
                _currentComponent,
                _initialDragTargetRect,
                _dragTargetRectDidChange,
                _currentDropEffect;

            function getElementRect(el) {
                if (el.nodeType !== ELEMENT_NODE) {
                    el = el.parentElement;
                }

                if (!el) {
                    return null;
                }

                var rect = el.getBoundingClientRect();
                // Copy so object doesn't get reused
                return { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            }

            function getClientOffset(e) {
                return {
                    x: e.clientX,
                    y: e.clientY
                };
            }

            function checkIfCurrentDragTargetRectChanged() {
                if (!_dragTargetRectDidChange) {
                    var currentRect = getElementRect(_currentDragTarget);
                    _dragTargetRectDidChange = !shallowEqual(_initialDragTargetRect, currentRect);
                }

                return _dragTargetRectDidChange;
            }

            function triggerDragEndIfDragSourceWasRemovedFromDOM() {
                if (!_currentComponent || document.body.contains(_currentDragTarget)) {
                    return;
                }

                var type = DragOperationStore.getDraggedItemType();
                _currentComponent.handleDragEnd(type, null);
            }

            function isDraggingNativeItem() {
                var itemType = DragOperationStore.getDraggedItemType();
                return isNativeDraggedItemType(itemType);
            }

            function handleTopDragStart(e) {
                if (DragOperationStore.isDragging()) {
                    return;
                }

                if (isUrlDragDropEvent(e)) {
                    // URL dragged from inside the document
                    DragDropActionCreators.startDragging(NativeDragItemTypes.URL, null);
                } else {
                    // If by this time no drag source reacted, tell browser not to drag.
                    e.preventDefault();
                }
            }

            function handleTopDragEnterCapture(e) {
                // IE requires this to not show a nodrag icon over the container
                e.preventDefault();

                var isFirstEnter = _monitor.enter(e.target);
                if (!isFirstEnter || DragOperationStore.isDragging()) {
                    return;
                }

                // It is important to try to catch these at capture phase.
                // This is currently the only way to have drop zones recognize
                // they're being hovered if they fill the screen completely.

                if (isFileDragDropEvent(e)) {
                    // File dragged from outside the document
                    DragDropActionCreators.startDragging(NativeDragItemTypes.FILE, null);
                } else if (isUrlDragDropEvent(e)) {
                    // URL dragged from outside the document
                    DragDropActionCreators.startDragging(NativeDragItemTypes.URL, null);
                }
            }

            function handleTopDragOver(e) {
                if (isDraggingNativeItem()) {
                    e.preventDefault();
                }

                var offsetFromClient = getClientOffset(e);
                DragDropActionCreators.drag(offsetFromClient);

                // At the top level of event bubbling, use previously set drop effect and reset it.
                if (_currentDropEffect) {
                    e.dataTransfer.dropEffect = _currentDropEffect;
                    _currentDropEffect = null;
                }

                if (_currentDragTarget && isWebkit() && checkIfCurrentDragTargetRectChanged()) {
                    // Prevent animating to incorrect position
                    e.preventDefault();
                }
            }

            function handleTopDragLeaveCapture(e) {
                if (isDraggingNativeItem()) {
                    e.preventDefault();
                }

                var isLastLeave = _monitor.leave(e.target);
                if (!isLastLeave || !isDraggingNativeItem()) {
                    return;
                }

                DragDropActionCreators.endDragging();
            }

            function handleTopDrop(e) {
                if (isDraggingNativeItem()) {
                    e.preventDefault();
                }

                _monitor.reset();

                if (isDraggingNativeItem()) {
                    DragDropActionCreators.endDragging();
                }

                triggerDragEndIfDragSourceWasRemovedFromDOM();
            }

            var HTML5 = {
                setup: function setup() {
                    if (typeof window === "undefined") {
                        return;
                    }

                    window.addEventListener("dragstart", handleTopDragStart);
                    window.addEventListener("dragenter", handleTopDragEnterCapture, true);
                    window.addEventListener("dragleave", handleTopDragLeaveCapture, true);
                    window.addEventListener("dragover", handleTopDragOver);
                    window.addEventListener("drop", handleTopDrop);
                },

                teardown: function teardown() {
                    if (typeof window === "undefined") {
                        return;
                    }

                    window.removeEventListener("dragstart", handleTopDragStart);
                    window.removeEventListener("dragenter", handleTopDragEnterCapture, true);
                    window.removeEventListener("dragleave", handleTopDragLeaveCapture, true);
                    window.removeEventListener("dragover", handleTopDragOver);
                    window.removeEventListener("drop", handleTopDrop);
                },

                beginDrag: function beginDrag(component, e, containerNode, dragPreview, dragAnchors, offsetFromContainer, effectsAllowed) {
                    var _e$nativeEvent = e.nativeEvent;
                    var dataTransfer = _e$nativeEvent.dataTransfer;
                    var target = _e$nativeEvent.target;
                    configureDataTransfer(dataTransfer, containerNode, dragPreview, dragAnchors, offsetFromContainer, effectsAllowed);

                    _currentComponent = component;
                    _currentDragTarget = target;
                    _initialDragTargetRect = getElementRect(target);
                    _dragTargetRectDidChange = false;

                    // Mouse event tell us that dragging has ended but `dragend` didn't fire.
                    // This may happen if source DOM was removed while dragging.

                    window.addEventListener("mousemove", triggerDragEndIfDragSourceWasRemovedFromDOM, true);
                },

                endDrag: function endDrag() {
                    _currentDragTarget = null;
                    _currentComponent = null;
                    _initialDragTargetRect = null;
                    _dragTargetRectDidChange = false;

                    window.removeEventListener("mousemove", triggerDragEndIfDragSourceWasRemovedFromDOM, true);
                },

                dragOver: function dragOver(component, e, dropEffect) {
                    // As event bubbles top-down, first specified effect will be used
                    if (!_currentDropEffect) {
                        _currentDropEffect = dropEffect;
                    }
                },

                getDragSourceProps: function getDragSourceProps(component, type) {
                    return {
                        draggable: true,
                        onDragStart: component.handleDragStart.bind(component, type),
                        onDragEnd: component.handleDragEnd.bind(component, type)
                    };
                },

                getDropTargetProps: function getDropTargetProps(component, types) {
                    return {
                        onDragEnter: component.handleDragEnter.bind(component, types),
                        onDragOver: component.handleDragOver.bind(component, types),
                        onDragLeave: component.handleDragLeave.bind(component, types),
                        onDrop: component.handleDrop.bind(component, types)
                    };
                },

                getOffsetFromClient: function getOffsetFromClient(component, e) {
                    return getClientOffset(e);
                }
            };

            module.exports = HTML5;

            /***/ },
        /* 34 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            module.exports = {
                HTML5: __webpack_require__(33)
            };

            /***/ },
        /* 35 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragOperationStore = __webpack_require__(13),
                DragOffsetStore = __webpack_require__(12);

            var DragLayerMixin = {
                getInitialState: function getInitialState() {
                    return this.getStateForDragLayerMixin();
                },

                getDragLayerState: function getDragLayerState() {
                    var _state = this.state;
                    var isDragging = _state.isDragging;
                    var draggedItemType = _state.draggedItemType;
                    var draggedItem = _state.draggedItem;
                    var initialOffset = _state.initialOffset;
                    var currentOffset = _state.currentOffset;
                    var currentOffsetFromClient = _state.currentOffsetFromClient;
                    var initialOffsetFromClient = _state.initialOffsetFromClient;
                    var initialOffsetFromContainer = _state.initialOffsetFromContainer;


                    return {
                        isDragging: isDragging,
                        draggedItemType: draggedItemType,
                        draggedItem: draggedItem,
                        initialOffset: initialOffset,
                        currentOffset: currentOffset,
                        currentOffsetFromClient: currentOffsetFromClient,
                        initialOffsetFromClient: initialOffsetFromClient,
                        initialOffsetFromContainer: initialOffsetFromContainer
                    };
                },

                getStateForDragLayerMixin: function getStateForDragLayerMixin() {
                    var initialOffsetFromClient = DragOffsetStore.getInitialOffsetFromClient(),
                        currentOffsetFromClient = DragOffsetStore.getCurrentOffsetFromClient(),
                        initialOffsetFromContainer = DragOffsetStore.getInitialOffsetFromContainer(),
                        isDragging = false,
                        draggedItemType = null,
                        draggedItem = null,
                        initialOffset = null,
                        currentOffset = null;

                    if (initialOffsetFromClient && currentOffsetFromClient) {
                        isDragging = true;
                        draggedItemType = DragOperationStore.getDraggedItemType();
                        draggedItem = DragOperationStore.getDraggedItem();

                        initialOffset = {
                            x: initialOffsetFromClient.x - initialOffsetFromContainer.x,
                            y: initialOffsetFromClient.y - initialOffsetFromContainer.y
                        };

                        currentOffset = {
                            x: currentOffsetFromClient.x - initialOffsetFromContainer.x,
                            y: currentOffsetFromClient.y - initialOffsetFromContainer.y
                        };
                    }

                    return {
                        isDragging: isDragging,
                        draggedItemType: draggedItemType,
                        draggedItem: draggedItem,
                        initialOffset: initialOffset,
                        currentOffset: currentOffset,
                        currentOffsetFromClient: currentOffsetFromClient,
                        initialOffsetFromClient: initialOffsetFromClient,
                        initialOffsetFromContainer: initialOffsetFromContainer
                    };
                },

                handleStoreChangeInDragLayerMixin: function handleStoreChangeInDragLayerMixin() {
                    if (this.isMounted()) {
                        this.setState(this.getStateForDragLayerMixin());
                    }
                },

                componentDidMount: function componentDidMount() {
                    DragOffsetStore.addChangeListener(this.handleStoreChangeInDragLayerMixin);
                    DragOperationStore.addChangeListener(this.handleStoreChangeInDragLayerMixin);
                },

                componentWillUnmount: function componentWillUnmount() {
                    DragOffsetStore.removeChangeListener(this.handleStoreChangeInDragLayerMixin);
                    DragOperationStore.removeChangeListener(this.handleStoreChangeInDragLayerMixin);
                }
            };

            module.exports = DragLayerMixin;

            /***/ },
        /* 36 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var getDragImageScale = __webpack_require__(46);

            var TRANSPARENT_PIXEL_SRC = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

            var ImagePreloaderMixin = {
                componentDidMount: function componentDidMount() {
                    this._cachedImages = {};
                    this._readyImages = {};
                    this.preloadImages();
                },

                componentDidUpdate: function componentDidUpdate() {
                    this.preloadImages();
                },

                componentWillUnmount: function componentWillUnmount() {
                    for (var key in this._cachedImages) {
                        this._cachedImages[key].src = TRANSPARENT_PIXEL_SRC;
                    }

                    this._cachedImages = {};
                },

                hasPreloadedImage: function hasPreloadedImage(url) {
                    return !!this._readyImages[url];
                },

                getPreloadedImage: function getPreloadedImage(url) {
                    if (this.hasPreloadedImage(url)) {
                        return this._cachedImages[url];
                    }
                },

                preloadImages: function preloadImages() {
                    var urls = this.getImageUrlsToPreload();
                    urls.forEach(this.preloadImage);
                },

                preloadImage: function preloadImage(url) {
                    var _this = this;
                    if (!url || this._cachedImages[url]) {
                        return;
                    }

                    var img = new Image();
                    img.onload = function () {
                        if (_this.isMounted()) {
                            _this._readyImages[url] = true;
                        }
                    };
                    img.onerror = function () {
                        if (_this.isMounted()) {
                            delete _this._cachedImages[url];
                        }
                    };
                    img.src = url;

                    this._cachedImages[url] = img;
                },

                getDragImageScale: getDragImageScale
            };

            module.exports = ImagePreloaderMixin;

            /***/ },
        /* 37 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var invariant = __webpack_require__(18),
                noop = __webpack_require__(32);

            var DefaultDragSource = {
                canDrag: function canDrag() {
                    return true;
                },

                beginDrag: function beginDrag() {
                    invariant(false, "Drag source must contain a method called beginDrag. See https://github.com/gaearon/react-dnd#drag-source-api");
                },

                endDrag: noop
            };

            module.exports = DefaultDragSource;

            /***/ },
        /* 38 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var noop = __webpack_require__(32);

            var DefaultDropTarget = {
                canDrop: function canDrop() {
                    return true;
                },

                getDropEffect: function getDropEffect(component, allowedEffects) {
                    return allowedEffects[0];
                },

                enter: noop,
                over: noop,
                leave: noop,
                acceptDrop: noop
            };

            module.exports = DefaultDropTarget;

            /***/ },
        /* 39 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragOffsetStore = __webpack_require__(12);

            var DragDropContext = {
                getCurrentOffsetDelta: function getCurrentOffsetDelta() {
                    var initialOffset = DragOffsetStore.getInitialOffsetFromClient(),
                        currentOffset = DragOffsetStore.getCurrentOffsetFromClient();

                    return {
                        x: currentOffset.x - initialOffset.x,
                        y: currentOffset.y - initialOffset.y
                    };
                },

                getInitialOffsetFromClient: function getInitialOffsetFromClient() {
                    return DragOffsetStore.getInitialOffsetFromClient();
                },

                getCurrentOffsetFromClient: function getCurrentOffsetFromClient() {
                    return DragOffsetStore.getCurrentOffsetFromClient();
                },

                getInitialOffsetFromContainer: function getInitialOffsetFromContainer() {
                    return DragOffsetStore.getInitialOffsetFromContainer();
                }
            };

            module.exports = DragDropContext;

            /***/ },
        /* 40 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var shouldUseDragPreview = __webpack_require__(49),
                getDragImageOffset = __webpack_require__(45),
                getBrowserEffectAllowed = __webpack_require__(44);

            function configureDataTransfer(dataTransfer, containerNode, dragPreview, dragAnchors, offsetFromContainer, effectsAllowed) {
                try {
                    // Firefox won't drag without setting data
                    dataTransfer.setData("application/json", {});
                } catch (err) {}

                if (shouldUseDragPreview(dragPreview) && dataTransfer.setDragImage) {
                    var dragOffset = getDragImageOffset(containerNode, dragPreview, dragAnchors, offsetFromContainer);
                    dataTransfer.setDragImage(dragPreview, dragOffset.x, dragOffset.y);
                }

                dataTransfer.effectAllowed = getBrowserEffectAllowed(effectsAllowed);
            }

            module.exports = configureDataTransfer;
            // IE doesn't support MIME types in setData

            /***/ },
        /* 41 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DragDropActionCreators = __webpack_require__(20),
                DragOperationStore = __webpack_require__(13),
                DragDropContext = __webpack_require__(39),
                EnterLeaveMonitor = __webpack_require__(23),
                DropEffects = __webpack_require__(9),
                DefaultDragSource = __webpack_require__(37),
                DefaultDropTarget = __webpack_require__(38),
                extractNativeItem = __webpack_require__(43),
                isNativeDraggedItemType = __webpack_require__(26),
                invariant = __webpack_require__(18),
                assign = __webpack_require__(17),
                defaults = __webpack_require__(76),
                isArray = __webpack_require__(7),
                isObject = __webpack_require__(1);

            function checkValidType(component, type) {
                /*jshint -W122 */
                invariant(type && (typeof type === "string" || typeof type === "symbol"), "Expected item type to be a non-empty string or a symbol. See %s", component.constructor.displayName);
            }

            function checkDragSourceDefined(component, type) {
                var displayName = component.constructor.displayName;

                invariant(component._dragSources[type], "There is no drag source for \"%s\" registered in %s. " + "Have you forgotten to register it? " + "See configureDragDrop in %s", type, displayName, displayName);
            }

            function checkDropTargetDefined(component, type) {
                var displayName = component.constructor.displayName;

                invariant(component._dropTargets[type], "There is no drop target for \"%s\" registered in %s. " + "Have you forgotten to register it? " + "See configureDragDrop in %s", type, displayName, displayName);
            }

            function createDragDropMixin(backend) {
                var refs = 0;

                function useBackend(component) {
                    if (refs === 0) {
                        backend.setup(component);
                    }
                    refs++;
                }

                function unuseBackend(component) {
                    refs--;
                    if (refs === 0) {
                        backend.teardown(component);
                    }
                }

                /**
                 * Use this mixin to define drag sources and drop targets.
                 */
                return {
                    getInitialState: function getInitialState() {
                        var state = {
                            ownDraggedItemType: null,
                            currentDropEffect: null
                        };

                        return assign(state, this.getStateForDragDropMixin());
                    },

                    getActiveDropTargetType: function getActiveDropTargetType() {
                        var _state = this.state;
                        var draggedItemType = _state.draggedItemType;
                        var draggedItem = _state.draggedItem;
                        var ownDraggedItemType = _state.ownDraggedItemType;
                        var dropTarget = this._dropTargets[draggedItemType];

                        if (!dropTarget) {
                            return null;
                        }

                        if (draggedItemType === ownDraggedItemType) {
                            return null;
                        }

                        var canDrop = dropTarget.canDrop;
                        return canDrop(this, draggedItem) ? draggedItemType : null;
                    },

                    isAnyDropTargetActive: function isAnyDropTargetActive(types) {
                        return types.indexOf(this.getActiveDropTargetType()) > -1;
                    },

                    getStateForDragDropMixin: function getStateForDragDropMixin() {
                        return {
                            draggedItem: DragOperationStore.getDraggedItem(),
                            draggedItemType: DragOperationStore.getDraggedItemType()
                        };
                    },

                    getDragState: function getDragState(type) {
                        checkValidType(this, type);
                        checkDragSourceDefined(this, type);

                        return {
                            isDragging: this.state.ownDraggedItemType === type
                        };
                    },

                    getDropState: function getDropState(type) {
                        checkValidType(this, type);
                        checkDropTargetDefined(this, type);

                        var isDragging = this.getActiveDropTargetType() === type,
                            isHovering = !!this.state.currentDropEffect;

                        return {
                            isDragging: isDragging,
                            isHovering: isDragging && isHovering
                        };
                    },

                    componentWillMount: function componentWillMount() {
                        this._monitor = new EnterLeaveMonitor();
                        this._dragSources = {};
                        this._dropTargets = {};

                        invariant(this.constructor.configureDragDrop, "%s must implement static configureDragDrop(register, context) to use DragDropMixin", this.constructor.displayName);

                        this.constructor.configureDragDrop(this.registerDragDropItemTypeHandlers, DragDropContext);
                    },

                    componentDidMount: function componentDidMount() {
                        useBackend(this);
                        DragOperationStore.addChangeListener(this.handleStoreChangeInDragDropMixin);
                    },

                    componentWillUnmount: function componentWillUnmount() {
                        unuseBackend(this);
                        DragOperationStore.removeChangeListener(this.handleStoreChangeInDragDropMixin);
                    },

                    registerDragDropItemTypeHandlers: function registerDragDropItemTypeHandlers(type, handlers) {
                        checkValidType(this, type);

                        var dragSource = handlers.dragSource;
                        var dropTarget = handlers.dropTarget;


                        if (dragSource) {
                            invariant(!this._dragSources[type], "Drag source for %s specified twice. See configureDragDrop in %s", type, this.constructor.displayName);

                            this._dragSources[type] = defaults(dragSource, DefaultDragSource);
                        }

                        if (dropTarget) {
                            invariant(!this._dropTargets[type], "Drop target for %s specified twice. See configureDragDrop in %s", type, this.constructor.displayName);

                            this._dropTargets[type] = defaults(dropTarget, DefaultDropTarget);
                        }
                    },

                    handleStoreChangeInDragDropMixin: function handleStoreChangeInDragDropMixin() {
                        if (this.isMounted()) {
                            this.setState(this.getStateForDragDropMixin());
                        }
                    },

                    dragSourceFor: function dragSourceFor(type) {
                        checkValidType(this, type);
                        checkDragSourceDefined(this, type);

                        return backend.getDragSourceProps(this, type);
                    },

                    handleDragStart: function handleDragStart(type, e) {
                        var _this = this;
                        var _dragSources$type = this._dragSources[type];
                        var canDrag = _dragSources$type.canDrag;
                        var beginDrag = _dragSources$type.beginDrag;
                        if (DragOperationStore.isDragging() || !canDrag(this)) {
                            return;
                        }

                        var _beginDrag = beginDrag(this);

                        var item = _beginDrag.item;
                        var dragPreview = _beginDrag.dragPreview;
                        var dragAnchors = _beginDrag.dragAnchors;
                        var effectsAllowed = _beginDrag.effectsAllowed;
                        var containerNode = this.getDOMNode();
                        var containerRect = containerNode.getBoundingClientRect();
                        var offsetFromClient = backend.getOffsetFromClient(this, e);
                        var offsetFromContainer;

                        offsetFromContainer = {
                            x: offsetFromClient.x - containerRect.left,
                            y: offsetFromClient.y - containerRect.top
                        };

                        if (!dragPreview) {
                            dragPreview = containerNode;
                        }

                        if (!effectsAllowed) {
                            // Move is a sensible default drag effect.
                            // Browser shows a drag preview anyway so we usually don't want "+" icon.
                            effectsAllowed = [DropEffects.MOVE];
                        }

                        invariant(isArray(effectsAllowed) && effectsAllowed.length > 0, "Expected effectsAllowed to be non-empty array");
                        invariant(isObject(item), "Expected return value of beginDrag to contain \"item\" object");

                        backend.beginDrag(this, e, containerNode, dragPreview, dragAnchors, offsetFromContainer, effectsAllowed);
                        DragDropActionCreators.startDragging(type, item, effectsAllowed, offsetFromClient, offsetFromContainer);

                        // Delay setting own state by a tick so `getDragState(type).isDragging`
                        // doesn't return `true` yet. Otherwise browser will capture dragged state
                        // as the element screenshot.

                        setTimeout(function () {
                            if (_this.isMounted() && DragOperationStore.getDraggedItem() === item) {
                                _this.setState({
                                    ownDraggedItemType: type
                                });
                            }
                        });
                    },

                    handleDragEnd: function handleDragEnd(type) {
                        backend.endDrag(this);

                        var endDrag = this._dragSources[type].endDrag;
                        var effect = DragOperationStore.getDropEffect();

                        DragDropActionCreators.endDragging();

                        // Note: this method may be invoked even *after* component was unmounted
                        // This happens if source node was removed from DOM while dragging.

                        if (this.isMounted()) {
                            this.setState({
                                ownDraggedItemType: null
                            });
                        }

                        endDrag(this, effect);
                    },

                    dropTargetFor: function dropTargetFor() {
                        var _this = this;
                        for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
                            types[_key] = arguments[_key];
                        }

                        types.forEach(function (type) {
                            checkValidType(_this, type);
                            checkDropTargetDefined(_this, type);
                        });

                        return backend.getDropTargetProps(this, types);
                    },

                    handleDragEnter: function handleDragEnter(types, e) {
                        if (!this.isAnyDropTargetActive(types)) {
                            return;
                        }

                        if (!this._monitor.enter(e.target)) {
                            return;
                        }

                        // IE requires this to trigger dragOver events
                        e.preventDefault();

                        var _dropTargets$state$draggedItemType = this._dropTargets[this.state.draggedItemType];
                        var enter = _dropTargets$state$draggedItemType.enter;
                        var getDropEffect = _dropTargets$state$draggedItemType.getDropEffect;
                        var effectsAllowed = DragOperationStore.getEffectsAllowed();
                        var itemType = DragOperationStore.getDraggedItemType();

                        if (isNativeDraggedItemType(itemType)) {
                            // Use Copy drop effect for dragging files or urls.
                            // Because browser gives no drag preview, "+" icon is useful.
                            effectsAllowed = [DropEffects.COPY];
                        }

                        var dropEffect = getDropEffect(this, effectsAllowed);
                        if (dropEffect) {
                            invariant(effectsAllowed.indexOf(dropEffect) > -1, "Effect %s supplied by drop target is not one of the effects allowed by drag source: %s", dropEffect, effectsAllowed.join(", "));
                        }

                        this.setState({
                            currentDropEffect: dropEffect
                        });

                        enter(this, this.state.draggedItem);
                    },

                    handleDragOver: function handleDragOver(types, e) {
                        if (!this.isAnyDropTargetActive(types)) {
                            return;
                        }

                        e.preventDefault();

                        var over = this._dropTargets[this.state.draggedItemType].over;
                        over(this, this.state.draggedItem);

                        // Don't use `none` because this will prevent browser from firing `dragend`
                        backend.dragOver(this, e, this.state.currentDropEffect || "move");
                    },

                    handleDragLeave: function handleDragLeave(types, e) {
                        if (!this.isAnyDropTargetActive(types)) {
                            return;
                        }

                        if (!this._monitor.leave(e.target)) {
                            return;
                        }

                        this.setState({
                            currentDropEffect: null
                        });

                        var leave = this._dropTargets[this.state.draggedItemType].leave;
                        leave(this, this.state.draggedItem);
                    },

                    handleDrop: function handleDrop(types, e) {
                        if (!this.isAnyDropTargetActive(types)) {
                            return;
                        }

                        e.preventDefault();

                        var item = this.state.draggedItem;
                        var acceptDrop = this._dropTargets[this.state.draggedItemType].acceptDrop;
                        var currentDropEffect = this.state.currentDropEffect;
                        var isHandled = !!DragOperationStore.getDropEffect();

                        // We don't know the exact list until the `drop` event,
                        // so we couldn't put `item` into the store.

                        if (!item) {
                            item = extractNativeItem(e);
                        }

                        this._monitor.reset();

                        if (!isHandled) {
                            DragDropActionCreators.recordDrop(currentDropEffect);
                        }

                        this.setState({
                            currentDropEffect: null
                        });

                        acceptDrop(this, item, isHandled, DragOperationStore.getDropEffect());
                    }
                };
            }

            module.exports = createDragDropMixin;

            /***/ },
        /* 42 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            function endsWith(str, suffix) {
                return str.indexOf(suffix, str.length - suffix.length) !== -1;
            }

            module.exports = endsWith;

            /***/ },
        /* 43 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var isFileDragDropEvent = __webpack_require__(25),
                isUrlDragDropEvent = __webpack_require__(27);

            function extractNativeItem(e) {
                if (isFileDragDropEvent(e)) {
                    return {
                        files: Array.prototype.slice.call(e.dataTransfer.files)
                    };
                } else if (isUrlDragDropEvent(e)) {
                    return {
                        urls: (e.dataTransfer.getData("Url") || e.dataTransfer.getData("text/uri-list") || "").split("\n")
                    };
                }
            }

            module.exports = extractNativeItem;

            /***/ },
        /* 44 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var DropEffects = __webpack_require__(9);

            function getBrowserEffectAllowed(effectsAllowed) {
                var allowCopy = effectsAllowed.indexOf(DropEffects.COPY) > -1,
                    allowMove = effectsAllowed.indexOf(DropEffects.MOVE) > -1,
                    allowLink = effectsAllowed.indexOf(DropEffects.LINK) > -1;

                if (allowCopy && allowMove && allowLink) {
                    return "all";
                } else if (allowCopy && allowMove) {
                    return "copyMove";
                } else if (allowLink && allowMove) {
                    return "linkMove";
                } else if (allowCopy && allowLink) {
                    return "copyLink";
                } else if (allowCopy) {
                    return "copy";
                } else if (allowMove) {
                    return "move";
                } else if (allowLink) {
                    return "link";
                } else {
                    return "none";
                }
            }

            module.exports = getBrowserEffectAllowed;

            /***/ },
        /* 45 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var HorizontalDragAnchors = __webpack_require__(21),
                VerticalDragAnchors = __webpack_require__(22),
                isSafari = __webpack_require__(14);

            /**
             * Returns offset to be used as arguments for `dataTransfer.setDragImage(dragImage, x, y)`.
             * Attempts to work around browser differences, especially on high-DPI screens.
             */
            function getDragImageOffset(containerNode, dragPreview, dragAnchors, offsetFromContainer) {
                dragAnchors = dragAnchors || {};

                var containerWidth = containerNode.offsetWidth;
                var containerHeight = containerNode.offsetHeight;
                var isImage = dragPreview instanceof Image;
                var previewWidth = isImage ? dragPreview.width : containerWidth;
                var previewHeight = isImage ? dragPreview.height : containerHeight;
                var horizontalAnchor = dragAnchors.horizontal || HorizontalDragAnchors.CENTER;
                var verticalAnchor = dragAnchors.vertical || VerticalDragAnchors.CENTER;var x = offsetFromContainer.x;
                var y = offsetFromContainer.y;


                // Work around @2x coordinate discrepancies in browsers
                if (isSafari()) {
                    previewHeight /= window.devicePixelRatio;
                    previewWidth /= window.devicePixelRatio;
                }

                switch (horizontalAnchor) {
                    case HorizontalDragAnchors.LEFT:
                        break;
                    case HorizontalDragAnchors.CENTER:
                        x *= previewWidth / containerWidth;
                        break;
                    case HorizontalDragAnchors.RIGHT:
                        x = previewWidth - previewWidth * (1 - x / containerWidth);
                        break;
                }

                switch (verticalAnchor) {
                    case VerticalDragAnchors.TOP:
                        break;
                    case VerticalDragAnchors.CENTER:
                        y *= previewHeight / containerHeight;
                        break;
                    case VerticalDragAnchors.BOTTOM:
                        y = previewHeight - previewHeight * (1 - y / containerHeight);
                        break;
                }

                // Work around Safari 8 positioning bug
                if (isSafari()) {
                    // We'll have to wait for @3x to see if this is entirely correct
                    y += (window.devicePixelRatio - 1) * previewHeight;
                }

                return {
                    x: x,
                    y: y
                };
            }

            module.exports = getDragImageOffset;

            /***/ },
        /* 46 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var isFirefox = __webpack_require__(47),
                isSafari = __webpack_require__(14);

            function getDragImageScale() {
                if (isFirefox() || isSafari()) {
                    return window.devicePixelRatio;
                } else {
                    return 1;
                }
            }

            module.exports = getDragImageScale;

            /***/ },
        /* 47 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            function isFirefox() {
                return /firefox/i.test(navigator.userAgent);
            }

            module.exports = isFirefox;

            /***/ },
        /* 48 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            function isWebkit() {
                return "WebkitAppearance" in document.documentElement.style;
            }

            module.exports = isWebkit;

            /***/ },
        /* 49 */
        /***/ function(module, exports, __webpack_require__) {

            "use strict";

            var isSafari = __webpack_require__(14),
                endsWith = __webpack_require__(42);

            function shouldUseDragPreview(dragPreview) {
                if (!dragPreview) {
                    return false;
                }

                if (isSafari() && dragPreview instanceof Image && endsWith(dragPreview.src, ".gif")) {
                    // GIFs crash Safari
                    return false;
                }

                return true;
            }

            module.exports = shouldUseDragPreview;

            /***/ },
        /* 50 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright (c) 2014-2015, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             */

            module.exports.Dispatcher = __webpack_require__(51);


            /***/ },
        /* 51 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright (c) 2014-2015, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             *
             * @providesModule Dispatcher
             *
             * @preventMunge
             */

            'use strict';

            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

            var invariant = __webpack_require__(52);

            var _prefix = 'ID_';

            /**
             * Dispatcher is used to broadcast payloads to registered callbacks. This is
             * different from generic pub-sub systems in two ways:
             *
             *   1) Callbacks are not subscribed to particular events. Every payload is
             *      dispatched to every registered callback.
             *   2) Callbacks can be deferred in whole or part until other callbacks have
             *      been executed.
             *
             * For example, consider this hypothetical flight destination form, which
             * selects a default city when a country is selected:
             *
             *   var flightDispatcher = new Dispatcher();
             *
             *   // Keeps track of which country is selected
             *   var CountryStore = {country: null};
             *
             *   // Keeps track of which city is selected
             *   var CityStore = {city: null};
             *
             *   // Keeps track of the base flight price of the selected city
             *   var FlightPriceStore = {price: null}
             *
             * When a user changes the selected city, we dispatch the payload:
             *
             *   flightDispatcher.dispatch({
	 *     actionType: 'city-update',
	 *     selectedCity: 'paris'
	 *   });
             *
             * This payload is digested by `CityStore`:
             *
             *   flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'city-update') {
	 *       CityStore.city = payload.selectedCity;
	 *     }
	 *   });
             *
             * When the user selects a country, we dispatch the payload:
             *
             *   flightDispatcher.dispatch({
	 *     actionType: 'country-update',
	 *     selectedCountry: 'australia'
	 *   });
             *
             * This payload is digested by both stores:
             *
             *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'country-update') {
	 *       CountryStore.country = payload.selectedCountry;
	 *     }
	 *   });
             *
             * When the callback to update `CountryStore` is registered, we save a reference
             * to the returned token. Using this token with `waitFor()`, we can guarantee
             * that `CountryStore` is updated before the callback that updates `CityStore`
             * needs to query its data.
             *
             *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'country-update') {
	 *       // `CountryStore.country` may not be updated.
	 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
	 *       // `CountryStore.country` is now guaranteed to be updated.
	 *
	 *       // Select the default city for the new country
	 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
	 *     }
	 *   });
             *
             * The usage of `waitFor()` can be chained, for example:
             *
             *   FlightPriceStore.dispatchToken =
             *     flightDispatcher.register(function(payload) {
	 *       switch (payload.actionType) {
	 *         case 'country-update':
	 *         case 'city-update':
	 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
	 *           FlightPriceStore.price =
	 *             getFlightPriceStore(CountryStore.country, CityStore.city);
	 *           break;
	 *     }
	 *   });
             *
             * The `country-update` payload will be guaranteed to invoke the stores'
             * registered callbacks in order: `CountryStore`, `CityStore`, then
             * `FlightPriceStore`.
             */

            var Dispatcher = (function () {
                function Dispatcher() {
                    _classCallCheck(this, Dispatcher);

                    this._callbacks = {};
                    this._isDispatching = false;
                    this._isHandled = {};
                    this._isPending = {};
                    this._lastID = 1;
                }

                /**
                 * Registers a callback to be invoked with every dispatched payload. Returns
                 * a token that can be used with `waitFor()`.
                 */

                Dispatcher.prototype.register = function register(callback) {
                    var id = _prefix + this._lastID++;
                    this._callbacks[id] = callback;
                    return id;
                };

                /**
                 * Removes a callback based on its token.
                 */

                Dispatcher.prototype.unregister = function unregister(id) {
                    !this._callbacks[id] ? false ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
                    delete this._callbacks[id];
                };

                /**
                 * Waits for the callbacks specified to be invoked before continuing execution
                 * of the current callback. This method should only be used by a callback in
                 * response to a dispatched payload.
                 */

                Dispatcher.prototype.waitFor = function waitFor(ids) {
                    !this._isDispatching ? false ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
                    for (var ii = 0; ii < ids.length; ii++) {
                        var id = ids[ii];
                        if (this._isPending[id]) {
                            !this._isHandled[id] ? false ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
                            continue;
                        }
                        !this._callbacks[id] ? false ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
                        this._invokeCallback(id);
                    }
                };

                /**
                 * Dispatches a payload to all registered callbacks.
                 */

                Dispatcher.prototype.dispatch = function dispatch(payload) {
                    !!this._isDispatching ? false ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
                    this._startDispatching(payload);
                    try {
                        for (var id in this._callbacks) {
                            if (this._isPending[id]) {
                                continue;
                            }
                            this._invokeCallback(id);
                        }
                    } finally {
                        this._stopDispatching();
                    }
                };

                /**
                 * Is this Dispatcher currently dispatching.
                 */

                Dispatcher.prototype.isDispatching = function isDispatching() {
                    return this._isDispatching;
                };

                /**
                 * Call the callback stored with the given id. Also do some internal
                 * bookkeeping.
                 *
                 * @internal
                 */

                Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
                    this._isPending[id] = true;
                    this._callbacks[id](this._pendingPayload);
                    this._isHandled[id] = true;
                };

                /**
                 * Set up bookkeeping needed when dispatching.
                 *
                 * @internal
                 */

                Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
                    for (var id in this._callbacks) {
                        this._isPending[id] = false;
                        this._isHandled[id] = false;
                    }
                    this._pendingPayload = payload;
                    this._isDispatching = true;
                };

                /**
                 * Clear bookkeeping used for dispatching.
                 *
                 * @internal
                 */

                Dispatcher.prototype._stopDispatching = function _stopDispatching() {
                    delete this._pendingPayload;
                    this._isDispatching = false;
                };

                return Dispatcher;
            })();

            module.exports = Dispatcher;

            /***/ },
        /* 52 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright 2013-2015, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             *
             * @providesModule invariant
             */

            "use strict";

            /**
             * Use invariant() to assert state which your program assumes to be true.
             *
             * Provide sprintf-style format (only %s is supported) and arguments
             * to provide information about what broke and what you were
             * expecting.
             *
             * The invariant message will be stripped in production, but the invariant
             * will remain to ensure logic does not differ in production.
             */

            var invariant = function (condition, format, a, b, c, d, e, f) {
                if (false) {
                    if (format === undefined) {
                        throw new Error('invariant requires an error message argument');
                    }
                }

                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
                    } else {
                        var args = [a, b, c, d, e, f];
                        var argIndex = 0;
                        error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
                                return args[argIndex++];
                            }));
                    }

                    error.framesToPop = 1; // we don't care about invariant's own frame
                    throw error;
                }
            };

            module.exports = invariant;

            /***/ },
        /* 53 */
        /***/ function(module, exports, __webpack_require__) {

            var baseFlatten = __webpack_require__(62),
                baseUniq = __webpack_require__(64),
                restParam = __webpack_require__(3);

            /**
             * Creates an array of unique values, in order, from all of the provided arrays
             * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
             * for equality comparisons.
             *
             * @static
             * @memberOf _
             * @category Array
             * @param {...Array} [arrays] The arrays to inspect.
             * @returns {Array} Returns the new array of combined values.
             * @example
             *
             * _.union([1, 2], [4, 2], [2, 1]);
             * // => [1, 2, 4]
             */
            var union = restParam(function(arrays) {
                return baseUniq(baseFlatten(arrays, false, true));
            });

            module.exports = union;


            /***/ },
        /* 54 */
        /***/ function(module, exports, __webpack_require__) {

            var baseDifference = __webpack_require__(61),
                isArrayLike = __webpack_require__(2),
                restParam = __webpack_require__(3);

            /**
             * Creates an array excluding all provided values using
             * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
             * for equality comparisons.
             *
             * @static
             * @memberOf _
             * @category Array
             * @param {Array} array The array to filter.
             * @param {...*} [values] The values to exclude.
             * @returns {Array} Returns the new array of filtered values.
             * @example
             *
             * _.without([1, 2, 1, 3], 1, 2);
             * // => [3]
             */
            var without = restParam(function(array, values) {
                return isArrayLike(array)
                    ? baseDifference(array, values)
                    : [];
            });

            module.exports = without;


            /***/ },
        /* 55 */
        /***/ function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(global) {var cachePush = __webpack_require__(66),
                getNative = __webpack_require__(4);

                /** Native method references. */
                var Set = getNative(global, 'Set');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeCreate = getNative(Object, 'create');

                /**
                 *
                 * Creates a cache object to store unique values.
                 *
                 * @private
                 * @param {Array} [values] The values to cache.
                 */
                function SetCache(values) {
                    var length = values ? values.length : 0;

                    this.data = { 'hash': nativeCreate(null), 'set': new Set };
                    while (length--) {
                        this.push(values[length]);
                    }
                }

                // Add functions to the `Set` cache.
                SetCache.prototype.push = cachePush;

                module.exports = SetCache;

                /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

            /***/ },
        /* 56 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
                var index = -1,
                    length = values.length,
                    offset = array.length;

                while (++index < length) {
                    array[offset + index] = values[index];
                }
                return array;
            }

            module.exports = arrayPush;


            /***/ },
        /* 57 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Used by `_.defaults` to customize its `_.assign` use.
             *
             * @private
             * @param {*} objectValue The destination object property value.
             * @param {*} sourceValue The source object property value.
             * @returns {*} Returns the value to assign to the destination object.
             */
            function assignDefaults(objectValue, sourceValue) {
                return objectValue === undefined ? sourceValue : objectValue;
            }

            module.exports = assignDefaults;


            /***/ },
        /* 58 */
        /***/ function(module, exports, __webpack_require__) {

            var keys = __webpack_require__(31);

            /**
             * A specialized version of `_.assign` for customizing assigned values without
             * support for argument juggling, multiple sources, and `this` binding `customizer`
             * functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @param {Function} customizer The function to customize assigned values.
             * @returns {Object} Returns `object`.
             */
            function assignWith(object, source, customizer) {
                var index = -1,
                    props = keys(source),
                    length = props.length;

                while (++index < length) {
                    var key = props[index],
                        value = object[key],
                        result = customizer(value, source[key], key, object, source);

                    if ((result === result ? (result !== value) : (value === value)) ||
                        (value === undefined && !(key in object))) {
                        object[key] = result;
                    }
                }
                return object;
            }

            module.exports = assignWith;


            /***/ },
        /* 59 */
        /***/ function(module, exports, __webpack_require__) {

            var baseCopy = __webpack_require__(60),
                keys = __webpack_require__(31);

            /**
             * The base implementation of `_.assign` without support for argument juggling,
             * multiple sources, and `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssign(object, source) {
                return source == null
                    ? object
                    : baseCopy(source, keys(source), object);
            }

            module.exports = baseAssign;


            /***/ },
        /* 60 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copies properties of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy properties from.
             * @param {Array} props The property names to copy.
             * @param {Object} [object={}] The object to copy properties to.
             * @returns {Object} Returns `object`.
             */
            function baseCopy(source, props, object) {
                object || (object = {});

                var index = -1,
                    length = props.length;

                while (++index < length) {
                    var key = props[index];
                    object[key] = source[key];
                }
                return object;
            }

            module.exports = baseCopy;


            /***/ },
        /* 61 */
        /***/ function(module, exports, __webpack_require__) {

            var baseIndexOf = __webpack_require__(28),
                cacheIndexOf = __webpack_require__(29),
                createCache = __webpack_require__(30);

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /**
             * The base implementation of `_.difference` which accepts a single array
             * of values to exclude.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {Array} values The values to exclude.
             * @returns {Array} Returns the new array of filtered values.
             */
            function baseDifference(array, values) {
                var length = array ? array.length : 0,
                    result = [];

                if (!length) {
                    return result;
                }
                var index = -1,
                    indexOf = baseIndexOf,
                    isCommon = true,
                    cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                    valuesLength = values.length;

                if (cache) {
                    indexOf = cacheIndexOf;
                    isCommon = false;
                    values = cache;
                }
                outer:
                    while (++index < length) {
                        var value = array[index];

                        if (isCommon && value === value) {
                            var valuesIndex = valuesLength;
                            while (valuesIndex--) {
                                if (values[valuesIndex] === value) {
                                    continue outer;
                                }
                            }
                            result.push(value);
                        }
                        else if (indexOf(values, value, 0) < 0) {
                            result.push(value);
                        }
                    }
                return result;
            }

            module.exports = baseDifference;


            /***/ },
        /* 62 */
        /***/ function(module, exports, __webpack_require__) {

            var arrayPush = __webpack_require__(56),
                isArguments = __webpack_require__(16),
                isArray = __webpack_require__(7),
                isArrayLike = __webpack_require__(2),
                isObjectLike = __webpack_require__(6);

            /**
             * The base implementation of `_.flatten` with added support for restricting
             * flattening and specifying the start index.
             *
             * @private
             * @param {Array} array The array to flatten.
             * @param {boolean} [isDeep] Specify a deep flatten.
             * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
             * @param {Array} [result=[]] The initial result value.
             * @returns {Array} Returns the new flattened array.
             */
            function baseFlatten(array, isDeep, isStrict, result) {
                result || (result = []);

                var index = -1,
                    length = array.length;

                while (++index < length) {
                    var value = array[index];
                    if (isObjectLike(value) && isArrayLike(value) &&
                        (isStrict || isArray(value) || isArguments(value))) {
                        if (isDeep) {
                            // Recursively flatten arrays (susceptible to call stack limits).
                            baseFlatten(value, isDeep, isStrict, result);
                        } else {
                            arrayPush(result, value);
                        }
                    } else if (!isStrict) {
                        result[result.length] = value;
                    }
                }
                return result;
            }

            module.exports = baseFlatten;


            /***/ },
        /* 63 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * The base implementation of `_.property` without support for deep paths.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @returns {Function} Returns the new function.
             */
            function baseProperty(key) {
                return function(object) {
                    return object == null ? undefined : object[key];
                };
            }

            module.exports = baseProperty;


            /***/ },
        /* 64 */
        /***/ function(module, exports, __webpack_require__) {

            var baseIndexOf = __webpack_require__(28),
                cacheIndexOf = __webpack_require__(29),
                createCache = __webpack_require__(30);

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /**
             * The base implementation of `_.uniq` without support for callback shorthands
             * and `this` binding.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {Function} [iteratee] The function invoked per iteration.
             * @returns {Array} Returns the new duplicate free array.
             */
            function baseUniq(array, iteratee) {
                var index = -1,
                    indexOf = baseIndexOf,
                    length = array.length,
                    isCommon = true,
                    isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                    seen = isLarge ? createCache() : null,
                    result = [];

                if (seen) {
                    indexOf = cacheIndexOf;
                    isCommon = false;
                } else {
                    isLarge = false;
                    seen = iteratee ? [] : result;
                }
                outer:
                    while (++index < length) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value, index, array) : value;

                        if (isCommon && value === value) {
                            var seenIndex = seen.length;
                            while (seenIndex--) {
                                if (seen[seenIndex] === computed) {
                                    continue outer;
                                }
                            }
                            if (iteratee) {
                                seen.push(computed);
                            }
                            result.push(value);
                        }
                        else if (indexOf(seen, computed, 0) < 0) {
                            if (iteratee || isLarge) {
                                seen.push(computed);
                            }
                            result.push(value);
                        }
                    }
                return result;
            }

            module.exports = baseUniq;


            /***/ },
        /* 65 */
        /***/ function(module, exports, __webpack_require__) {

            var identity = __webpack_require__(78);

            /**
             * A specialized version of `baseCallback` which only supports `this` binding
             * and specifying the number of arguments to provide to `func`.
             *
             * @private
             * @param {Function} func The function to bind.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {number} [argCount] The number of arguments to provide to `func`.
             * @returns {Function} Returns the callback.
             */
            function bindCallback(func, thisArg, argCount) {
                if (typeof func != 'function') {
                    return identity;
                }
                if (thisArg === undefined) {
                    return func;
                }
                switch (argCount) {
                    case 1: return function(value) {
                        return func.call(thisArg, value);
                    };
                    case 3: return function(value, index, collection) {
                        return func.call(thisArg, value, index, collection);
                    };
                    case 4: return function(accumulator, value, index, collection) {
                        return func.call(thisArg, accumulator, value, index, collection);
                    };
                    case 5: return function(value, other, key, object, source) {
                        return func.call(thisArg, value, other, key, object, source);
                    };
                }
                return function() {
                    return func.apply(thisArg, arguments);
                };
            }

            module.exports = bindCallback;


            /***/ },
        /* 66 */
        /***/ function(module, exports, __webpack_require__) {

            var isObject = __webpack_require__(1);

            /**
             * Adds `value` to the cache.
             *
             * @private
             * @name push
             * @memberOf SetCache
             * @param {*} value The value to cache.
             */
            function cachePush(value) {
                var data = this.data;
                if (typeof value == 'string' || isObject(value)) {
                    data.set.add(value);
                } else {
                    data.hash[value] = true;
                }
            }

            module.exports = cachePush;


            /***/ },
        /* 67 */
        /***/ function(module, exports, __webpack_require__) {

            var bindCallback = __webpack_require__(65),
                isIterateeCall = __webpack_require__(71),
                restParam = __webpack_require__(3);

            /**
             * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
             *
             * @private
             * @param {Function} assigner The function to assign values.
             * @returns {Function} Returns the new assigner function.
             */
            function createAssigner(assigner) {
                return restParam(function(object, sources) {
                    var index = -1,
                        length = object == null ? 0 : sources.length,
                        customizer = length > 2 ? sources[length - 2] : undefined,
                        guard = length > 2 ? sources[2] : undefined,
                        thisArg = length > 1 ? sources[length - 1] : undefined;

                    if (typeof customizer == 'function') {
                        customizer = bindCallback(customizer, thisArg, 5);
                        length -= 2;
                    } else {
                        customizer = typeof thisArg == 'function' ? thisArg : undefined;
                        length -= (customizer ? 1 : 0);
                    }
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                        customizer = length < 3 ? undefined : customizer;
                        length = 1;
                    }
                    while (++index < length) {
                        var source = sources[index];
                        if (source) {
                            assigner(object, source, customizer);
                        }
                    }
                    return object;
                });
            }

            module.exports = createAssigner;


            /***/ },
        /* 68 */
        /***/ function(module, exports, __webpack_require__) {

            var restParam = __webpack_require__(3);

            /**
             * Creates a `_.defaults` or `_.defaultsDeep` function.
             *
             * @private
             * @param {Function} assigner The function to assign values.
             * @param {Function} customizer The function to customize assigned values.
             * @returns {Function} Returns the new defaults function.
             */
            function createDefaults(assigner, customizer) {
                return restParam(function(args) {
                    var object = args[0];
                    if (object == null) {
                        return object;
                    }
                    args.push(customizer);
                    return assigner.apply(undefined, args);
                });
            }

            module.exports = createDefaults;


            /***/ },
        /* 69 */
        /***/ function(module, exports, __webpack_require__) {

            var baseProperty = __webpack_require__(63);

            /**
             * Gets the "length" property value of `object`.
             *
             * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
             * that affects Safari on at least iOS 8.1-8.3 ARM64.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {*} Returns the "length" value.
             */
            var getLength = baseProperty('length');

            module.exports = getLength;


            /***/ },
        /* 70 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Gets the index at which the first occurrence of `NaN` is found in `array`.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {number} fromIndex The index to search from.
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {number} Returns the index of the matched `NaN`, else `-1`.
             */
            function indexOfNaN(array, fromIndex, fromRight) {
                var length = array.length,
                    index = fromIndex + (fromRight ? 0 : -1);

                while ((fromRight ? index-- : ++index < length)) {
                    var other = array[index];
                    if (other !== other) {
                        return index;
                    }
                }
                return -1;
            }

            module.exports = indexOfNaN;


            /***/ },
        /* 71 */
        /***/ function(module, exports, __webpack_require__) {

            var isArrayLike = __webpack_require__(2),
                isIndex = __webpack_require__(15),
                isObject = __webpack_require__(1);

            /**
             * Checks if the provided arguments are from an iteratee call.
             *
             * @private
             * @param {*} value The potential iteratee value argument.
             * @param {*} index The potential iteratee index or key argument.
             * @param {*} object The potential iteratee object argument.
             * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
             */
            function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                    return false;
                }
                var type = typeof index;
                if (type == 'number'
                        ? (isArrayLike(object) && isIndex(index, object.length))
                        : (type == 'string' && index in object)) {
                    var other = object[index];
                    return value === value ? (value === other) : (other !== other);
                }
                return false;
            }

            module.exports = isIterateeCall;


            /***/ },
        /* 72 */
        /***/ function(module, exports, __webpack_require__) {

            var isArguments = __webpack_require__(16),
                isArray = __webpack_require__(7),
                isIndex = __webpack_require__(15),
                isLength = __webpack_require__(5),
                keysIn = __webpack_require__(77);

            /** Used for native method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * A fallback implementation of `Object.keys` which creates an array of the
             * own enumerable property names of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function shimKeys(object) {
                var props = keysIn(object),
                    propsLength = props.length,
                    length = propsLength && object.length;

                var allowIndexes = !!length && isLength(length) &&
                    (isArray(object) || isArguments(object));

                var index = -1,
                    result = [];

                while (++index < propsLength) {
                    var key = props[index];
                    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                        result.push(key);
                    }
                }
                return result;
            }

            module.exports = shimKeys;


            /***/ },
        /* 73 */
        /***/ function(module, exports, __webpack_require__) {

            var isObject = __webpack_require__(1);

            /** `Object#toString` result references. */
            var funcTag = '[object Function]';

            /** Used for native method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objToString = objectProto.toString;

            /**
             * Checks if `value` is classified as a `Function` object.
             *
             * @static
             * @memberOf _
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
             * @example
             *
             * _.isFunction(_);
             * // => true
             *
             * _.isFunction(/abc/);
             * // => false
             */
            function isFunction(value) {
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in older versions of Chrome and Safari which return 'function' for regexes
                // and Safari 8 which returns 'object' for typed array constructors.
                return isObject(value) && objToString.call(value) == funcTag;
            }

            module.exports = isFunction;


            /***/ },
        /* 74 */
        /***/ function(module, exports, __webpack_require__) {

            var isFunction = __webpack_require__(73),
                isObjectLike = __webpack_require__(6);

            /** Used to detect host constructors (Safari > 5). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;

            /** Used for native method references. */
            var objectProto = Object.prototype;

            /** Used to resolve the decompiled source of functions. */
            var fnToString = Function.prototype.toString;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /** Used to detect if a method is native. */
            var reIsNative = RegExp('^' +
                fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
            );

            /**
             * Checks if `value` is a native function.
             *
             * @static
             * @memberOf _
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
             * @example
             *
             * _.isNative(Array.prototype.push);
             * // => true
             *
             * _.isNative(_);
             * // => false
             */
            function isNative(value) {
                if (value == null) {
                    return false;
                }
                if (isFunction(value)) {
                    return reIsNative.test(fnToString.call(value));
                }
                return isObjectLike(value) && reIsHostCtor.test(value);
            }

            module.exports = isNative;


            /***/ },
        /* 75 */
        /***/ function(module, exports, __webpack_require__) {

            var assignWith = __webpack_require__(58),
                baseAssign = __webpack_require__(59),
                createAssigner = __webpack_require__(67);

            /**
             * Assigns own enumerable properties of source object(s) to the destination
             * object. Subsequent sources overwrite property assignments of previous sources.
             * If `customizer` is provided it's invoked to produce the assigned values.
             * The `customizer` is bound to `thisArg` and invoked with five arguments:
             * (objectValue, sourceValue, key, object, source).
             *
             * **Note:** This method mutates `object` and is based on
             * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
             *
             * @static
             * @memberOf _
             * @alias extend
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @param {Function} [customizer] The function to customize assigned values.
             * @param {*} [thisArg] The `this` binding of `customizer`.
             * @returns {Object} Returns `object`.
             * @example
             *
             * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
             * // => { 'user': 'fred', 'age': 40 }
             *
             * // using a customizer callback
             * var defaults = _.partialRight(_.assign, function(value, other) {
	 *   return _.isUndefined(value) ? other : value;
	 * });
             *
             * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
             * // => { 'user': 'barney', 'age': 36 }
             */
            var assign = createAssigner(function(object, source, customizer) {
                return customizer
                    ? assignWith(object, source, customizer)
                    : baseAssign(object, source);
            });

            module.exports = assign;


            /***/ },
        /* 76 */
        /***/ function(module, exports, __webpack_require__) {

            var assign = __webpack_require__(75),
                assignDefaults = __webpack_require__(57),
                createDefaults = __webpack_require__(68);

            /**
             * Assigns own enumerable properties of source object(s) to the destination
             * object for all destination properties that resolve to `undefined`. Once a
             * property is set, additional values of the same property are ignored.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @example
             *
             * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
             * // => { 'user': 'barney', 'age': 36 }
             */
            var defaults = createDefaults(assign, assignDefaults);

            module.exports = defaults;


            /***/ },
        /* 77 */
        /***/ function(module, exports, __webpack_require__) {

            var isArguments = __webpack_require__(16),
                isArray = __webpack_require__(7),
                isIndex = __webpack_require__(15),
                isLength = __webpack_require__(5),
                isObject = __webpack_require__(1);

            /** Used for native method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * Creates an array of the own and inherited enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects.
             *
             * @static
             * @memberOf _
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keysIn(new Foo);
             * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
             */
            function keysIn(object) {
                if (object == null) {
                    return [];
                }
                if (!isObject(object)) {
                    object = Object(object);
                }
                var length = object.length;
                length = (length && isLength(length) &&
                    (isArray(object) || isArguments(object)) && length) || 0;

                var Ctor = object.constructor,
                    index = -1,
                    isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                    result = Array(length),
                    skipIndexes = length > 0;

                while (++index < length) {
                    result[index] = (index + '');
                }
                for (var key in object) {
                    if (!(skipIndexes && isIndex(key, length)) &&
                        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                        result.push(key);
                    }
                }
                return result;
            }

            module.exports = keysIn;


            /***/ },
        /* 78 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * This method returns the first argument provided to it.
             *
             * @static
             * @memberOf _
             * @category Utility
             * @param {*} value Any value.
             * @returns {*} Returns `value`.
             * @example
             *
             * var object = { 'user': 'fred' };
             *
             * _.identity(object) === object;
             * // => true
             */
            function identity(value) {
                return value;
            }

            module.exports = identity;


            /***/ },
        /* 79 */
        /***/ function(module, exports, __webpack_require__) {

            /**
             * Copyright 2013-2014, Facebook, Inc.
             * All rights reserved.
             *
             * This source code is licensed under the BSD-style license found in the
             * LICENSE file in the root directory of this source tree. An additional grant
             * of patent rights can be found in the PATENTS file in the same directory.
             *
             * @providesModule shallowEqual
             */

            "use strict";

            /**
             * Performs equality by iterating through keys on an object and returning
             * false when any key has values which are not strictly equal between
             * objA and objB. Returns true when the values of all keys are strictly equal.
             *
             * @return {boolean}
             */
            function shallowEqual(objA, objB) {
                if (objA === objB) {
                    return true;
                }
                var key;
                // Test for A's keys different from B.
                for (key in objA) {
                    if (objA.hasOwnProperty(key) &&
                        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
                        return false;
                    }
                }
                // Test for B's keys missing from A.
                for (key in objB) {
                    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
                        return false;
                    }
                }
                return true;
            }

            module.exports = shallowEqual;


            /***/ },
        /* 80 */
        /***/ function(module, exports, __webpack_require__) {

            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            function EventEmitter() {
                this._events = this._events || {};
                this._maxListeners = this._maxListeners || undefined;
            }
            module.exports = EventEmitter;

            // Backwards-compat with node 0.10.x
            EventEmitter.EventEmitter = EventEmitter;

            EventEmitter.prototype._events = undefined;
            EventEmitter.prototype._maxListeners = undefined;

            // By default EventEmitters will print a warning if more than 10 listeners are
            // added to it. This is a useful default which helps finding memory leaks.
            EventEmitter.defaultMaxListeners = 10;

            // Obviously not all Emitters should be limited to 10. This function allows
            // that to be increased. Set to zero for unlimited.
            EventEmitter.prototype.setMaxListeners = function(n) {
                if (!isNumber(n) || n < 0 || isNaN(n))
                    throw TypeError('n must be a positive number');
                this._maxListeners = n;
                return this;
            };

            EventEmitter.prototype.emit = function(type) {
                var er, handler, len, args, i, listeners;

                if (!this._events)
                    this._events = {};

                // If there is no 'error' event listener then throw.
                if (type === 'error') {
                    if (!this._events.error ||
                        (isObject(this._events.error) && !this._events.error.length)) {
                        er = arguments[1];
                        if (er instanceof Error) {
                            throw er; // Unhandled 'error' event
                        } else {
                            // At least give some kind of context to the user
                            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                            err.context = er;
                            throw err;
                        }
                    }
                }

                handler = this._events[type];

                if (isUndefined(handler))
                    return false;

                if (isFunction(handler)) {
                    switch (arguments.length) {
                        // fast cases
                        case 1:
                            handler.call(this);
                            break;
                        case 2:
                            handler.call(this, arguments[1]);
                            break;
                        case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;
                        // slower
                        default:
                            args = Array.prototype.slice.call(arguments, 1);
                            handler.apply(this, args);
                    }
                } else if (isObject(handler)) {
                    args = Array.prototype.slice.call(arguments, 1);
                    listeners = handler.slice();
                    len = listeners.length;
                    for (i = 0; i < len; i++)
                        listeners[i].apply(this, args);
                }

                return true;
            };

            EventEmitter.prototype.addListener = function(type, listener) {
                var m;

                if (!isFunction(listener))
                    throw TypeError('listener must be a function');

                if (!this._events)
                    this._events = {};

                // To avoid recursion in the case that type === "newListener"! Before
                // adding it to the listeners, first emit "newListener".
                if (this._events.newListener)
                    this.emit('newListener', type,
                        isFunction(listener.listener) ?
                            listener.listener : listener);

                if (!this._events[type])
                // Optimize the case of one listener. Don't need the extra array object.
                    this._events[type] = listener;
                else if (isObject(this._events[type]))
                // If we've already got an array, just append.
                    this._events[type].push(listener);
                else
                // Adding the second element, need to change to array.
                    this._events[type] = [this._events[type], listener];

                // Check for listener leak
                if (isObject(this._events[type]) && !this._events[type].warned) {
                    if (!isUndefined(this._maxListeners)) {
                        m = this._maxListeners;
                    } else {
                        m = EventEmitter.defaultMaxListeners;
                    }

                    if (m && m > 0 && this._events[type].length > m) {
                        this._events[type].warned = true;
                        console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.',
                            this._events[type].length);
                        if (typeof console.trace === 'function') {
                            // not supported in IE 10
                            console.trace();
                        }
                    }
                }

                return this;
            };

            EventEmitter.prototype.on = EventEmitter.prototype.addListener;

            EventEmitter.prototype.once = function(type, listener) {
                if (!isFunction(listener))
                    throw TypeError('listener must be a function');

                var fired = false;

                function g() {
                    this.removeListener(type, g);

                    if (!fired) {
                        fired = true;
                        listener.apply(this, arguments);
                    }
                }

                g.listener = listener;
                this.on(type, g);

                return this;
            };

            // emits a 'removeListener' event iff the listener was removed
            EventEmitter.prototype.removeListener = function(type, listener) {
                var list, position, length, i;

                if (!isFunction(listener))
                    throw TypeError('listener must be a function');

                if (!this._events || !this._events[type])
                    return this;

                list = this._events[type];
                length = list.length;
                position = -1;

                if (list === listener ||
                    (isFunction(list.listener) && list.listener === listener)) {
                    delete this._events[type];
                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);

                } else if (isObject(list)) {
                    for (i = length; i-- > 0;) {
                        if (list[i] === listener ||
                            (list[i].listener && list[i].listener === listener)) {
                            position = i;
                            break;
                        }
                    }

                    if (position < 0)
                        return this;

                    if (list.length === 1) {
                        list.length = 0;
                        delete this._events[type];
                    } else {
                        list.splice(position, 1);
                    }

                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);
                }

                return this;
            };

            EventEmitter.prototype.removeAllListeners = function(type) {
                var key, listeners;

                if (!this._events)
                    return this;

                // not listening for removeListener, no need to emit
                if (!this._events.removeListener) {
                    if (arguments.length === 0)
                        this._events = {};
                    else if (this._events[type])
                        delete this._events[type];
                    return this;
                }

                // emit removeListener for all listeners on all events
                if (arguments.length === 0) {
                    for (key in this._events) {
                        if (key === 'removeListener') continue;
                        this.removeAllListeners(key);
                    }
                    this.removeAllListeners('removeListener');
                    this._events = {};
                    return this;
                }

                listeners = this._events[type];

                if (isFunction(listeners)) {
                    this.removeListener(type, listeners);
                } else if (listeners) {
                    // LIFO order
                    while (listeners.length)
                        this.removeListener(type, listeners[listeners.length - 1]);
                }
                delete this._events[type];

                return this;
            };

            EventEmitter.prototype.listeners = function(type) {
                var ret;
                if (!this._events || !this._events[type])
                    ret = [];
                else if (isFunction(this._events[type]))
                    ret = [this._events[type]];
                else
                    ret = this._events[type].slice();
                return ret;
            };

            EventEmitter.prototype.listenerCount = function(type) {
                if (this._events) {
                    var evlistener = this._events[type];

                    if (isFunction(evlistener))
                        return 1;
                    else if (evlistener)
                        return evlistener.length;
                }
                return 0;
            };

            EventEmitter.listenerCount = function(emitter, type) {
                return emitter.listenerCount(type);
            };

            function isFunction(arg) {
                return typeof arg === 'function';
            }

            function isNumber(arg) {
                return typeof arg === 'number';
            }

            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }

            function isUndefined(arg) {
                return arg === void 0;
            }


            /***/ }
        /******/ ])
});

//# sourceMappingURL=ReactDND.min.js.map
